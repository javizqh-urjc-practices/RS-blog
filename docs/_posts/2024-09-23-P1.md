---
title: "P1: Localized Vacuum Cleaner"
date: 2024-09-23 18:00:00 +0100
tags: [weekly progress]     # TAG names should always be lowercase
author: javier
img_path: /assets/img/
toc: true
comments: true
pin: true
---

## Fitting the map

## Creating the grid

In order to create the a grid that was appropiate I first needed to decide which size of cell to go for.

For this I checked a multiple of combinations and found that the best one was resizing the map to 527x527 and using a 17x17 px cell. Here are some test grids:

* Cell: 19x19 | Resize: 494x494: Lost to much detail
![19x494](19x494.png)

* Cell: 19x19 | Resize: 513x513: Isolates one part of the house
![19x513](19x513.png)

* Cell: 17x17 | Resize: 510x510: Walls too thick
![17x510](17x510.png)

* Cell: 17x17 | Resize: 527x527: Good compromise
![17x527](17x527.png)

So with a size of the map and cell that seemed fine I checked that the cell size was slightly smaller than the vacuum cleaner to ensure that it cleans the cell in it's entirety.

The size of the cell in the original map was 32,64 px that is 93,2% of the vacuum size.

To see the issues that made this map not work, refer to the 'Issues during development' section at the end.

## Planning the path

The planning is divided in 2 main steps in order to follow BSA (Backtracking Spiral Algorithm):

* Doing a spiral movement
* Moving to the next starting cell

For the first part of the movements the priorities are set to WEST -> NORTH -> EAST -> SOUTH and this is check every time the path cannot continue in the same direction. Also when this case occurs that cell is stored as a part of the path, meaning that the final path is only composed of the points where the vacuum has to change directions.

In this image and video the colors of the cells mean:

* Yellow: The vacuum weall go through the cell
* Orange: Turning point and the ones added into the path
* Red: End of the spiral. Turning point and is added to the path
* Blue: Start of the spiral. Turning point and is added to the path
* Purple: Start of the next spiral also know as 'return neighbour'. Turning point and is added to the path

![Path Planning](Path1.png)

{% include embed/youtube.html id='jYSA5vP6kLQ' %}

With this the only thing left is to generate the path from the end of the spiral (Red) to the start of the next one (purple).

For this purpose I used BFS (Breadth first search) to find the shortest route moving only in the directions allowed: W, N, E, S.
This was necessary because not always going in a straight line to the goal is possible.

```python
def plan_move_to_cell(start, finish, grid):
    # Using Breadth First Search
    frontier = Queue(maxsize = 0) 
    expanded = [] 
    frontier.put((start, []))
    while not frontier.empty():
      node, path_to_node = frontier.get()
      if node[0] == finish[0] and node[1] == finish[1]:
        return path_to_node
      if not any((x[0] == node[0] and x[1] == node[1]) for x in expanded): 
        expanded.append(node)
        for child in get_all_neighbours(node, grid, finish):
          if not any((x[0] == child[0] and x[1] == child[1]) for x in expanded):
            frontier.put((child, path_to_node + [child] ))
    return path_to_node
```

The only issue remaining is that using BFS the path that returns does not comply with the things stated above (The path must only consist of turning points, not passing ones). For this reason it was needed to 'simplify' the path to only those points.

Now the two paths are added together and this continues until no possible movements are left.

## Movement

Instead of having 2 types of movement control: Go Forward and Rotate. I chose a to manage the movement as 1 single movement.

Thanks to the way the path is created, the vacuum only needs to move to the interest points (where the vacuum changes direction) I can simplify the movement into 2 parts of a single function.

1. Spin until the yaw of the vacuum matches the angle define by the inverse tangent of the distance in both axis to the point of interest.

```python
pose = HAL.getPose3d()
ang = math.degrees(math.atan((dest_y - pose.y)/(dest_x - pose.x)))

# Consider arctan symbol problems
if (dest_x - pose.x) < 0:
  if (dest_y - pose.y) < 0:
    ang -= 180
  else:
    ang += 180
```

2. Go forward until a certain threshold is met, in this case 15 cm.

In order to not fake any vacuum cleaning, I only paint as green the cells where the vacuum is in.

```python
pose = HAL.getPose3d()
x, y = pose_to_grid(pose)
clean_cell(x,y, grid, matrix)
```


## Issues during development

The main issue I encounter during the development was to not erode the main image. Why was this important?

Well, because of the size of the cell being 32.6 px and the vacuum being 35 px in some extreme cases the center of the cell was not reacheable and the vacuum crashed.

To solve this I eroded the image with a 5x5 kernel after resizing it to 527x527 and this solved the problem. The downside was now that the cleaning area was reduced by around 10%.

## Videos

The videos are at 10X speed, so the time it takes to clean the full house is around 30 minutes.

{% include embed/youtube.html id='cQF3FXRTKrs' %}

{% include embed/youtube.html id='7dwxaS7Arx0' %}
